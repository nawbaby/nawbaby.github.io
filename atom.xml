<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-12T05:07:28.407Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>脚本模板化</title>
    <link href="http://example.com/2020/10/12/interactive_shell/"/>
    <id>http://example.com/2020/10/12/interactive_shell/</id>
    <published>2020-10-12T11:18:37.000Z</published>
    <updated>2020-10-12T05:07:28.407Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="30cc6917246fd6c72161966cb1dc282610b38bbdc9ae0a930359ec03c4a74f2f">46f6e0c4b88908be10ead0a1e56dc85314a1c8eaa37c287d59e8b43763cb3900c44d9a965e4b4b3d58f1010512dc5d5b960020dcb4155fd635269ddea7d17a1d571bcc240140987e90d9a0f99b6f0464233d5a6512e1824495d43cf965c79041a51f4b87c3b983d0ca80e0fef226f34152c9306267fb916cc764073344957c59b5d756fe2c903749b0c4becaf5abefb996e5d2965c778ee832657c0ba6aa03f00af3e0830a3c816aff3485565f2af96ee093cb34abd40215c7feb7da262a5382bf80a7506bf4544ff33c4f77baddf0ca4c6fc160cb15415ab010a8e6b007db7b234ea4f030b45f7c6da90cf5a95b8300f4cf248c8f6530169f584cf82f83f3531d8e672beb3e596a01eddca684999f65cbf6a57f6d7aa24d9584df9b06e94d7f4d855a1ab86aad0d87b0c91595cdbf36bba8af5430c184a9bc22ef5a4b140cd6f281e2366584e8ac289aa0fdda4d293741d3876158def340c670af69bf4364a21ea1ce0fe0c6ea64a87cea571b21d2174e699c8cd4d868785258ec080aee404850228eecdd515dc2e647efe59d62cec3d6f260ed5e3e8e9bc5fa4c6a2e1c698b74085c13be97bb93cf482a0bc9e3c1919b2c89ea33ca74723ac153f6d36b3e309b9633a6e897eb5990b27322b0c1f82a2fd53a807e114dfa3c0b4329cb2d8f653ac7104fcf3270ebdfb5b419fda079eacf1a32d9e234404421222379008b657b87c3c2f0365e3619a957ee575f940c7ff3e9c2ad22f2de4ccb6cf7a669019d6d981eead1016d4e0cd17506e2c0f5c0fb89e876bb415ab1e70747b0c1a582ae7e95cc13c1146a6bb8e4872aa04ac7599fcd17d50b761d4671137614a53b5797454f4ebfffdcc198df347b1f7712ab2589c00954015c14e9a3347c6d9a094351b2394cd7e965322c7dbe1ef356be82a29a1345a932cc0874b40cbe9d2ebe3dbb97c6618a39d2c450c847c35bf2fdfe3b79377d097718a85d78f7ed7bf330626368b8be5d7aa911ba78702b35794fedc560df0b60838f62f0ad2cf368e44343058bca4e186d7d57a4a20b4847c2cf67e4b797e79255e26fa976f599063a417349fce1b0b61f70f88da4c7d94f366b475c52dba4cac9e6a3d093564ada8799262531ee5861e7a6156ef488dd79135d82343b6045454a1fbb89217a7d427e6089d30726e8b0305a3279a51333d284c899b946868414f45d3e36522ac8fd314b6529d448f9366a582ba25c5ad724c2a3676a1bdb90a238fe0d88401091fc75c5e35978d5a78d44e75904b70ff8143707897f13118109f0e89c19a6341572b87ef5f41f70577faa5d84df2e9b4dd513cd427027f129a7a0b1b51fe70485b6c78e8a077ca3252e876ece958ec0b5845a2984371f10fe1410a63a402a2796c282f2a1d4a84ab2a8362cedd383a6a4b32853810055aeb367f3d5f1ff85cb163cec35011631c9df7e445655a6b7c8caff8878ef67975c7c803647b168975a99043b1441be17b80d10d83d0dfc28e25621e78ee701ad4c4ec8e090006bc8d7d099daf209c87e248a31b78e6f21f5a1b8314e88961ae9e3fc3fd5a677b8b35514d1bb6ffb349ecd25ca7b5e898a9bbfe3bb6eaa86b40d5e3858ec2abe2c9be713714ee5779413fffb7508477af9091c31b98a37c9be8944c44595d80701f4510fb56ea8104bcedf6646b51d5b0f508a45a6f8c537d2ccb5cbbdf03af3e28740bf413fbea92bdcc989d95da660765971ffcc7a7e37ece352686343d922b8b5921587fb6f6f9059caff7a1246c7279d1b9edce2bc376aa7e1993aa6970de0bc57f258424efff3a2f6c237af568f83629cc5041befc6aac44dbe81cd1bae16bfaa78d2659c1c4a693ae1ae1fa2a41eb179e7758da88ead39cb4e1483f8bd633cb88d0cc4750ea12fdba5e341b7bcae11536150ac07ecad9830151f9512788b08cd3af1e3df6314b8537350215462fb9d1f3f2d57d25fb96a57f3947f8c8ca0a091c5ed3afa724e92cd1fc293b1df51b4a29eecf04c030a36c797bca45e63e7819a12eed726409384274530cb599d7f1d5a56369d9b523759f5bb928af965b77c7fdeace1f6003f34509364c1d1a02e9773a7ee1a624a21b6653f255d402f0b48ca605a1501216586a388fa863f5642ab5b21f780feb78f6cd9721ae4050e4eff3e7df0c4ef11f00ac460a9eda00bb0072195253fc55b6d619902962b0e6bcad283f9aa413b8b00e7ee0e3ad3fc85ce9248d5bbb6d7c27388963aafec3259776a0eb44ca86f8e6fcb6beec0bc34963a8a2204a1bf2bec3a383d350d81f2ac2d663dd7fa0145c0139f47b2c6b216be44ee4e3a02e8148139dc745cada5c044abc45bae759a6d68b700d7f8db90b193ba6a31dfa2dfd51540b1a1c1d6bbfe824cf25e12ca6fa0133013f9971b00d99b9e3c6275d4fdf0a7cf627b2607bc78d8358706ef856829dbb9efafd0f9a43341701a62cfc006cf249dc7d38dedc72aa39582d7822a414341a1424d0b8997e37678809758382bbd1464fa574532cf4cc2f869fad7e153ac9d7290e804c58c2a1880ebdd6b5ae31208ef363ad880b8b392972d4d2cf7854b50ae5c4a063466bb78e61bca065cb8710a16b89021f270cced4720318e44826fc9e1bbdc4accd9039486173e2e28d1ff4534369eab51674180abd497f2bfa96de3f19b8ba040a642264292eea147f604af3acee9d851755ce500df1123333c0e729578f4ff21d4a48f5cb6f5886a3b1c798849a51bde50a5d88ca765aaf1ab47f438b690f86c8b3ea805fd95eaf0aa4d863a9b3ddf35c569d1239ec979e23c02e87e4b4aae45bef79f404c3947b74fa5405bddc1cd3f570baa8ce5a89be0f2b7a8572f322ead3f163b8757d7196466ba43198cd3d2810209c3e8ebce3e4f55bdd5b208f057a1bb006e7637a61eaf552ea7d16cf325fb6723fef609b06f3ba93f5e23528d82bcd0a129fe3a1e549cf2415b23c3099be6812190e64c058d3748c39eba12c45e29480929fb71322c5d723f13b33367cd110379b566b6fc3fd2817eb2a71dc9f82f8b0957dd6b37d337caa215cc560c00f6d07712d9a61901eeff17a26e617e8255359973121e169f53c9eeae24bb511b52a9a39d9ed7575f5add095b6782d13fd79beb39007c2fc183c80deec3a6965219b7daa726da9537be247db1d2aff68a3febb3342a465e6ab3d4f09cdfc6cf53f2e85d66f9cdb8660191d3909c428a62c9762f578835ae4ed9150067592f45acc9d8aee9f687aaf10091e04a5ee33daf7c88560b9f45a171bdb467010b839c690f08695e4533bed65a1121db0988fac4e6ba6d90f6d2bf2273dfa02644b11aaa80c843a72e04b1a437ecc427074c2f74b2521d2236483bc6726c3306ceadbcfb7bb69c6ad0b987bc0449bee1a0d3200e67cbe9165a0b350cdf108b4f5622aa21bf66faa41f752876711ca6792c35b77aa69fb605eec1bf815bf3beb8e073b8c96155b77937414ab3e238c3d9d35e8cf74132440d9f5e278383fd7eb74a1e79c6c3c76cba6589a441bd52849f0c1ed1d67efdadc33ab408b6c3357e8e91a70028327c308262729b830400987cfe35cd00b773a2ec61badc0ff0cbaa0739bc9658c1497b21a6f3489e0cff9513feb956ab6d3eea85e63bfbd2cbd77ec2798281baafb5abead5f9e489867f2f1faf2cc4812843178f4b8e62a7675751bf4ec8619f718bc9953549ff4fe58eb586e92a99fc29f85b0cc37871b62114aa9d6edf44d4241c98001910404e2237eac6af9b19361fad688d5a04f1d8137924e46616ded2f44f3bbd7e53ca7aad44c740ef59d8d3d4f5ce44841ca8577fd71dc44a1b7662a7b04683c45475051a19608854665328e1a8626cb71f63fbbf7aa7eae402d275e7315933783f7a9d4351c407f0c21fe9b708136e8101ad927a22fd65e92ffa2aebc744e174ee0efe85f1deb31d6f94768bf1ff1e6bd1ab9b4bb904987ad256d0616a31ed0fb9b50293a77efe452aced31384fa69bbc53a2e10d95951c247c9cb60eec815588065acb42a088ca2d97b3c27ec7e8b09655442b31676aed41e3ea32287719d0826fa597854fce18968c368b2fc1c6bb7f42757d5fce4bdae5c82de3da1022f3b17c45dcad46f6bfd5ff9621c5d51b4c78e04f3c57d8d7c5e754c8f971910b01a3e1c154a8871baaa6139a049f354e8cfcb778c661f35c14b9f8e4d4c02e3905a0aea0d2e6122b35cfebf089837cb55d9dcdb3598f84100b2472c7d123abe3ce332c584948dc8321fc48601f3a1027c823a4a965359d9addc9499959763e110f00fb9923d3348803afb1cfde09bdc84b3a53f5e80370ea82317aa88c824132730704e078e9f38eabc4bb50d686616b4b2b17217a25b55fe85d922651d7e35d16b2e9cc1f23c4c661f52d150e137df99d559bbb0df53fcf3dafe5adfa5e0f2b199b11757d38ff7e71f29101df5abee06edf55c2ddb39cdb3075c4fceaa8580a72d3e81e6051cd5d478cffe4a13f60eeb6da70639f2c92622f41ca80812333fa21081e52e5034b0bb3a6771feaa200f3716cf62c92f50419ba0f724e266292a4f5365a42498dfbbc234c91d85d74b1c1a69362a2c4ed5300d071344c92db244c40c989869417bd55342282e329ca7a41e252f47c5e1b6dbffc0eef28176e30bd27e92ae833ae36aedf5fc098a22f581b25abcf75097c6755a173a501201269ce4b7898a8faffbc16822ed408ed735947b13d9b1855217ec8c6bdfce65769a615bb0582a347150d26631facdd16e9dd42bb77e57afdfaabba8c4c59a8f364a360a4bdec2737769017db29d03be87441307183710f28250fd6178e177606be0ff2dc51945f7d62407abc43f777e93727ce68ce1658487c9d9700418b99a236d904a34d1493a106a12ae528cb2a5506f9f167f34652b105268d435ac78539b9c7932ddd100f5d7ab55e31c10c39eca5fb5f31f045f5568207109cd63</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="水笔" scheme="http://example.com/tags/%E6%B0%B4%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>1号笔记</title>
    <link href="http://example.com/2020/10/10/%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/10/10/%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-10T15:29:37.000Z</published>
    <updated>2020-10-10T07:32:26.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用引用的方式写正文应该可以提升下阅读的体验</p></blockquote><p>事实证明vi也可以用来写md,所以md软件的作用大概是体现所见即所得，</p><p>处于练手期的同学使用的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;用引用的方式写正文应该可以提升下阅读的体验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事实证明vi也可以用来写md,所以md软件的作用大概是体现所见即所得，&lt;/p&gt;
&lt;p&gt;处于练手期的同学使用的&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>solaris</title>
    <link href="http://example.com/2020/10/10/solaris/"/>
    <id>http://example.com/2020/10/10/solaris/</id>
    <published>2020-10-10T06:13:48.000Z</published>
    <updated>2020-10-12T03:43:48.535Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="hljs mermaid">graph LROpenSolaris--&gt;illumos</code></pre><blockquote><p><em>OpenSolaris闭源产生了illumos</em></p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic2.zhimg.com/80/v2-743d5d236933938d8310b68e7ef7023d_720w.jpg?source=1940ef5c" alt="image"></h2><p><strong>illumos的特性</strong></p><ul><li>zfs</li><li>zone 轻量级虚拟机  LXC</li><li>crossbow 网络虚拟化</li><li>Dtrace 系统管理员的武器，macos 上的instruments</li><li>kvm type2虚拟化技术</li></ul><hr><p><strong>内核</strong></p><blockquote><p>于是illumos = ZFS + Zone + Crossbow + Dtrace + KVM。所有云计算的关键服务在这里集合，形成了一个为云计算而生的系统内核。</p></blockquote><hr><pre><code class="hljs mermaid">graph LRillumos--&gt;openindianillumos--&gt;smartos</code></pre><p><em>smartos的运维管理系统smartDataCenter</em></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;hljs mermaid&quot;&gt;graph LR
OpenSolaris--&amp;gt;illumos&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;OpenSolaris闭源产生了illumos&lt;/em&gt;&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mermaid的使用</title>
    <link href="http://example.com/2020/10/10/mermaid/"/>
    <id>http://example.com/2020/10/10/mermaid/</id>
    <published>2020-10-10T00:00:00.000Z</published>
    <updated>2020-10-12T07:22:34.787Z</updated>
    
    <content type="html"><![CDATA[<p>这里是摘要</p><a id="more"></a><script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts-gl@1.1.1/dist/echarts-gl.min.js"></script><hr><script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script><!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --><div id="main" style="width: 600px;height:400px;"></div><script type="text/javascript">  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('main'));  // 指定图表的配置项和数据  var option = {    xAxis: {        type: 'category',        boundaryGap: false    },    yAxis: {        type: 'value',        boundaryGap: [0, '30%']    },    visualMap: {        type: 'piecewise',        show: false,        dimension: 0,        seriesIndex: 0,        pieces: [{            gt: 1,            lt: 3,            color: 'rgba(0, 180, 0, 0.5)'        }, {            gt: 5,            lt: 7,            color: 'rgba(0, 180, 0, 0.5)'        }]    },    series: [        {            type: 'line',            smooth: 0.6,            symbol: 'none',            lineStyle: {                color: 'green',                width: 5            },            markLine: {                symbol: ['none', 'none'],                label: {show: false},                data: [                    {xAxis: 1},                    {xAxis: 3},                    {xAxis: 5},                    {xAxis: 7}                ]            },            areaStyle: {},            data: [                ['2019-10-10', 200],                ['2019-10-11', 400],                ['2019-10-12', 650],                ['2019-10-13', 500],                ['2019-10-14', 250],                ['2019-10-15', 300],                ['2019-10-16', 450],                ['2019-10-17', 300],                ['2019-10-18', 100]            ]        }    ]};  // 使用刚指定的配置项和数据显示图表。  myChart.setOption(option);  // 刷新调整  window.onresize = function () {    myChart.resize();  }</script><iframe src="http://www.baidu.com/" width="100%" height="500" name="topFrame" scrolling="yes"  noresize="noresize" frameborder="0" id="topFrame"></iframe><h3 id="练习在markdown中使用mermaid"><a href="#练习在markdown中使用mermaid" class="headerlink" title="练习在markdown中使用mermaid"></a>练习在markdown中使用mermaid</h3><hr><h4 id="一、基础图形与基础与基础形状"><a href="#一、基础图形与基础与基础形状" class="headerlink" title="一、基础图形与基础与基础形状"></a>一、基础图形与基础与基础形状</h4><pre><code class="hljs angelscript">graph TD;<span class="hljs-number">11</span>[直角矩形]<span class="hljs-number">22</span>(圆角矩形)<span class="hljs-number">33</span>((圆形))<span class="hljs-number">44</span>&#123;棱形&#125;<span class="hljs-number">55</span>&gt;奇怪的形状]<span class="hljs-number">1</span>(起始位置)id2(准备材料)id3(操作流程)id4(收尾工作)<span class="hljs-number">1</span> --&gt; id2<span class="hljs-number">1</span> ==&gt; id3<span class="hljs-number">1</span> -.-&gt; id4</code></pre><pre><code class="hljs mermaid">graph TD;11[直角矩形]22(圆角矩形)33((圆形))44&#123;棱形&#125;55&gt;奇怪的形状]1(起始位置)id2(准备材料)id3(操作流程)id4(收尾工作)1 --&gt; id21 &#x3D;&#x3D;&gt; id31 -.-&gt; id4</code></pre><hr><h4 id="二、稍微复杂的图形"><a href="#二、稍微复杂的图形" class="headerlink" title="二、稍微复杂的图形"></a>二、稍微复杂的图形</h4><pre><code class="hljs erlang-repl">sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great!</code></pre><pre><code class="hljs mermaid">sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great!</code></pre><hr><h4 id="三、子图（还没搞明白）"><a href="#三、子图（还没搞明白）" class="headerlink" title="三、子图（还没搞明白）"></a>三、子图（还没搞明白）</h4><pre><code class="hljs armasm"><span class="hljs-symbol">graph</span> TB        subgraph one    <span class="hljs-built_in">a1</span>    <span class="hljs-built_in">a2</span>    <span class="hljs-meta">end</span>    subgraph two    b1--&gt;b2    <span class="hljs-meta">end</span>    subgraph three    <span class="hljs-built_in">c1</span>--&gt;<span class="hljs-built_in">c2</span>    <span class="hljs-meta">end</span></code></pre><pre><code class="hljs mermaid">graph TB        subgraph one    a1    a2    end    subgraph two    b1--&gt;b2    end    subgraph three    c1--&gt;c2    end</code></pre><hr><h4 id="四、花里胡哨的样式"><a href="#四、花里胡哨的样式" class="headerlink" title="四、花里胡哨的样式"></a>四、花里胡哨的样式</h4><p>(控制格子的样式)</p><pre><code class="hljs apache"><span class="hljs-attribute">graph</span> LR    <span class="hljs-attribute">id1</span>(Start)--&gt;id<span class="hljs-number">2</span>(Stop)    <span class="hljs-attribute">style</span> id<span class="hljs-number">1</span> fill:#f<span class="hljs-number">9</span>f,stroke:#<span class="hljs-number">333</span>,stroke-width:<span class="hljs-number">4</span>px    <span class="hljs-attribute">style</span> id<span class="hljs-number">2</span> fill:#ccf,stroke:#f<span class="hljs-number">66</span>,stroke-width:<span class="hljs-number">2</span>px,stroke-dasharray: <span class="hljs-number">5</span>, <span class="hljs-number">5</span></code></pre><pre><code class="hljs mermaid">graph LR    id1(Start)--&gt;id2(Stop)    style id1 fill:#f9f,stroke:#333,stroke-width:4px    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5</code></pre><hr><h4 id="五、图标"><a href="#五、图标" class="headerlink" title="五、图标"></a>五、图标</h4><pre><code class="hljs reasonml">graph LR    B<span class="hljs-literal">[&quot;<span class="hljs-identifier">fa</span>:<span class="hljs-identifier">fa</span>-<span class="hljs-identifier">twitter</span> 和平&quot;]</span>    B--&gt;C<span class="hljs-literal">[<span class="hljs-identifier">fa</span>:<span class="hljs-identifier">fa</span>-<span class="hljs-identifier">ban</span> 禁止]</span>    B--&gt;<span class="hljs-constructor">D(<span class="hljs-params">fa</span>:<span class="hljs-params">fa</span>-<span class="hljs-params">spinner</span>)</span>;    B--&gt;<span class="hljs-constructor">E(A <span class="hljs-params">fa</span>:<span class="hljs-params">fa</span>-<span class="hljs-params">camera</span>-<span class="hljs-params">retro</span> 也许?)</span>;</code></pre><pre><code class="hljs mermaid">graph LR    B[&quot;fa:fa-twitter 和平&quot;]    B--&gt;C[fa:fa-ban 禁止]    B--&gt;D(fa:fa-spinner);    B--&gt;E(A fa:fa-camera-retro 也许?);</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里是摘要&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>rabbit</title>
    <link href="http://example.com/2020/10/09/rabbit/"/>
    <id>http://example.com/2020/10/09/rabbit/</id>
    <published>2020-10-09T07:01:49.514Z</published>
    <updated>2020-10-09T07:01:49.501Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-rabbitmq-%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85">一文搞懂 RabbitMQ 的重要概念以及安装</a><ul><li><a href="#%E4%B8%80-rabbitmq-%E4%BB%8B%E7%BB%8D">一 RabbitMQ 介绍</a><ul><li><a href="#11-rabbitmq-%E7%AE%80%E4%BB%8B">1.1 RabbitMQ 简介</a></li><li><a href="#12-rabbitmq-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">1.2 RabbitMQ 核心概念</a><ul><li><a href="#121-producer%E7%94%9F%E4%BA%A7%E8%80%85-%E5%92%8C-consumer%E6%B6%88%E8%B4%B9%E8%80%85">1.2.1 Producer(生产者) 和 Consumer(消费者)</a></li><li><a href="#122-exchange%E4%BA%A4%E6%8D%A2%E5%99%A8">1.2.2 Exchange(交换器)</a></li><li><a href="#123-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">1.2.3 Queue(消息队列)</a></li><li><a href="#124-broker%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9">1.2.4 Broker（消息中间件的服务节点）</a></li><li><a href="#125-exchange-types%E4%BA%A4%E6%8D%A2%E5%99%A8%E7%B1%BB%E5%9E%8B">1.2.5 Exchange Types(交换器类型)</a><ul><li><a href="#%E2%91%A0-fanout">① fanout</a></li><li><a href="#%E2%91%A1-direct">② direct</a></li><li><a href="#%E2%91%A2-topic">③ topic</a></li><li><a href="#%E2%91%A3-headers%E4%B8%8D%E6%8E%A8%E8%8D%90">④ headers(不推荐)</a></li></ul></li></ul></li></ul></li><li><a href="#%E4%BA%8C-%E5%AE%89%E8%A3%85-rabbitmq">二 安装 RabbitMq</a><ul><li><a href="#21-%E5%AE%89%E8%A3%85-erlang">2.1 安装 erlang</a></li><li><a href="#22-%E5%AE%89%E8%A3%85-rabbitmq">2.2 安装 RabbitMQ</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="一文搞懂-RabbitMQ-的重要概念以及安装"><a href="#一文搞懂-RabbitMQ-的重要概念以及安装" class="headerlink" title="一文搞懂 RabbitMQ 的重要概念以及安装"></a>一文搞懂 RabbitMQ 的重要概念以及安装</h1><h2 id="一-RabbitMQ-介绍"><a href="#一-RabbitMQ-介绍" class="headerlink" title="一 RabbitMQ 介绍"></a>一 RabbitMQ 介绍</h2><p>这部分参考了 《RabbitMQ实战指南》这本书的第 1 章和第 2 章。</p><h3 id="1-1-RabbitMQ-简介"><a href="#1-1-RabbitMQ-简介" class="headerlink" title="1.1 RabbitMQ 简介"></a>1.1 RabbitMQ 简介</h3><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p><p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p><ul><li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li><li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们将 RabbitMQ 核心概念的时候详细介绍到。</li><li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li><li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li><li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li><li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li><li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li><li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li></ul><h3 id="1-2-RabbitMQ-核心概念"><a href="#1-2-RabbitMQ-核心概念" class="headerlink" title="1.2 RabbitMQ 核心概念"></a>1.2 RabbitMQ 核心概念</h3><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p><p>下面再来看看图1—— RabbitMQ 的整体模型架构。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/96388546.jpg" alt="图1-RabbitMQ 的整体模型架构"></p><p>下面我会一一介绍上图中的一些概念。</p><h4 id="1-2-1-Producer-生产者-和-Consumer-消费者"><a href="#1-2-1-Producer-生产者-和-Consumer-消费者" class="headerlink" title="1.2.1 Producer(生产者) 和 Consumer(消费者)"></a>1.2.1 Producer(生产者) 和 Consumer(消费者)</h4><ul><li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li><li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li></ul><p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p><h4 id="1-2-2-Exchange-交换器"><a href="#1-2-2-Exchange-交换器" class="headerlink" title="1.2.2 Exchange(交换器)"></a>1.2.2 Exchange(交换器)</h4><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p><p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p><p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)**，</strong>fanout**, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p><p>Exchange(交换器) 示意图如下：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/24007899.jpg" alt="Exchange(交换器) 示意图"></p><p>生产者将消息发给交换器的时候，一般会指定一个 <strong>RoutingKey(路由键)**，用来指定这个消息的路由规则，而这个 **RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p><p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p><p>Binding(绑定) 示意图：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/70553134.jpg" alt="Binding(绑定) 示意图"></p><p>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p><h4 id="1-2-3-Queue-消息队列"><a href="#1-2-3-Queue-消息队列" class="headerlink" title="1.2.3 Queue(消息队列)"></a>1.2.3 Queue(消息队列)</h4><p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p><p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。</p><p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p><h4 id="1-2-4-Broker（消息中间件的服务节点）"><a href="#1-2-4-Broker（消息中间件的服务节点）" class="headerlink" title="1.2.4 Broker（消息中间件的服务节点）"></a>1.2.4 Broker（消息中间件的服务节点）</h4><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p><p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/67952922.jpg" alt="消息队列的运转过程"></p><p>这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p><h4 id="1-2-5-Exchange-Types-交换器类型"><a href="#1-2-5-Exchange-Types-交换器类型" class="headerlink" title="1.2.5 Exchange Types(交换器类型)"></a>1.2.5 Exchange Types(交换器类型)</h4><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p><h5 id="①-fanout"><a href="#①-fanout" class="headerlink" title="① fanout"></a>① fanout</h5><p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p><h5 id="②-direct"><a href="#②-direct" class="headerlink" title="② direct"></a>② direct</h5><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。 </p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/37008021.jpg" alt="direct 类型交换器"></p><p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p><p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p><h5 id="③-topic"><a href="#③-topic" class="headerlink" title="③ topic"></a>③ topic</h5><p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p><ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“<em>”和“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li></ul><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/73843.jpg" alt="topic 类型交换器"></p><p>以上图为例：</p><ul><li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queuel 和 Queue2;</li><li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li><li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li><li>路由键为 “java.rabbitmq.demo” 的消息只会路由到Queuel中；</li><li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li></ul><h5 id="④-headers-不推荐"><a href="#④-headers-不推荐" class="headerlink" title="④ headers(不推荐)"></a>④ headers(不推荐)</h5><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p><h2 id="二-安装-RabbitMq"><a href="#二-安装-RabbitMq" class="headerlink" title="二 安装 RabbitMq"></a>二 安装 RabbitMq</h2><p>通过 Docker 安装非常方便，只需要几条命令就好了，我这里是只说一下常规安装方法。</p><p>前面提到了 RabbitMQ 是由 Erlang语言编写的，也正因如此，在安装RabbitMQ 之前需要安装 Erlang。</p><p>注意：在安装 RabbitMQ 的时候需要注意 RabbitMQ 和 Erlang 的版本关系，如果不注意的话会导致出错，两者对应关系如下:</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RabbitMQ-Erlang.png" alt="RabbitMQ 和 Erlang 的版本关系"></p><h3 id="2-1-安装-erlang"><a href="#2-1-安装-erlang" class="headerlink" title="2.1 安装 erlang"></a>2.1 安装 erlang</h3><p><strong>1 下载 erlang 安装包</strong></p><p>在官网下载然后上传到 Linux 上或者直接使用下面的命令下载对应的版本。</p><pre><code class="hljs shell">[root@SnailClimb local]#wget http://erlang.org/download/otp_src_19.3.tar.gz</code></pre><p>erlang 官网下载：<a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a>  </p><p> <strong>2 解压 erlang 安装包</strong></p><pre><code class="hljs shell">[root@SnailClimb local]#tar -xvzf otp_src_19.3.tar.gz</code></pre><p><strong>3 删除 erlang 安装包</strong></p><pre><code class="hljs shell">[root@SnailClimb local]#rm -rf otp_src_19.3.tar.gz</code></pre><p><strong>4 安装 erlang 的依赖工具</strong></p><pre><code class="hljs shell">[root@SnailClimb local]#yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel</code></pre><p><strong>5 进入erlang 安装包解压文件对 erlang 进行安装环境的配置</strong></p><p>新建一个文件夹</p><pre><code class="hljs shell">[root@SnailClimb local]# mkdir erlang</code></pre><p>对 erlang 进行安装环境的配置</p><pre><code class="hljs shell">[root@SnailClimb otp_src_19.3]# ./configure --prefix=/usr/local/erlang --without-javac</code></pre><p><strong>6 编译安装</strong></p><pre><code class="hljs shell">[root@SnailClimb otp_src_19.3]# make &amp;&amp; make install</code></pre><p><strong>7 验证一下 erlang 是否安装成功了</strong></p><pre><code class="hljs shell">[root@SnailClimb otp_src_19.3]# ./bin/erl</code></pre><p>运行下面的语句输出“hello world”</p><pre><code class="hljs erlang">io:format(<span class="hljs-string">&quot;hello world~n&quot;</span>, []).</code></pre><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/49570541.jpg" alt="输出“hello world”"></p><p>大功告成，我们的 erlang 已经安装完成。</p><p><strong>8 配置  erlang 环境变量</strong></p><pre><code class="hljs shell">[root@SnailClimb etc]# vim profile</code></pre><p>追加下列环境变量到文件末尾</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">erlang</span>ERL_HOME=/usr/local/erlangPATH=$ERL_HOME/bin:$PATHexport ERL_HOME PATH</code></pre><p>运行下列命令使配置文件<code>profile</code>生效</p><pre><code class="hljs shell">[root@SnailClimb etc]# source /etc/profile</code></pre><p>输入 erl 查看 erlang 环境变量是否配置正确</p><pre><code class="hljs shell">[root@SnailClimb etc]# erl</code></pre><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/62504246.jpg" alt="输入 erl 查看 erlang 环境变量是否配置正确"></p><h3 id="2-2-安装-RabbitMQ"><a href="#2-2-安装-RabbitMQ" class="headerlink" title="2.2 安装 RabbitMQ"></a>2.2 安装 RabbitMQ</h3><p><strong>1. 下载rpm</strong> </p><pre><code class="hljs shell">wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.8/rabbitmq-server-3.6.8-1.el7.noarch.rpm</code></pre><p>或者直接在官网下载</p><p><a href="https://www.rabbitmq.com/install-rpm.html">https://www.rabbitmq.com/install-rpm.html</a></p><p><strong>2. 安装rpm</strong></p><pre><code class="hljs shell">rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc</code></pre><p>紧接着执行：</p><pre><code class="hljs shell">yum install rabbitmq-server-3.6.8-1.el7.noarch.rpm</code></pre><p>中途需要你输入”y”才能继续安装。</p><p><strong>3 开启 web 管理插件</strong></p><pre><code class="hljs shell">rabbitmq-plugins enable rabbitmq_management</code></pre><p><strong>4 设置开机启动</strong></p><pre><code class="hljs shell">chkconfig rabbitmq-server on</code></pre><p><strong>4. 启动服务</strong></p><pre><code class="hljs shell">service rabbitmq-server start</code></pre><p><strong>5. 查看服务状态</strong></p><pre><code class="hljs shell">service rabbitmq-server status</code></pre><p><strong>6. 访问 RabbitMQ 控制台</strong></p><p>浏览器访问：http://你的ip地址:15672/</p><p>默认用户名和密码： guest/guest;但是需要注意的是：guestuest用户只是被容许从localhost访问。官网文档描述如下：</p><pre><code class="hljs shell">“guest” user can only connect via localhost</code></pre><p><strong>解决远程访问 RabbitMQ 远程访问密码错误</strong></p><p>新建用户并授权 </p><pre><code class="hljs shell">[root@SnailClimb rabbitmq]# rabbitmqctl add_user root rootCreating user &quot;root&quot; ...[root@SnailClimb rabbitmq]# rabbitmqctl set_user_tags root administratorSetting tags for user &quot;root&quot; to [administrator] ...[root@SnailClimb rabbitmq]# [root@SnailClimb rabbitmq]# rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;Setting permissions for user &quot;root&quot; in vhost &quot;/&quot; ...</code></pre><p>再次访问:http://你的ip地址:15672/ ,输入用户名和密码：root root</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/45835332.jpg" alt="RabbitMQ控制台"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-rabbitmq-%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%</summary>
      
    
    
    
    
  </entry>
  
</feed>
